Orison — Terminal-first OOP Learning Roadmap (MVP-first, step-by-step)

How we will work
- Each task ships a tiny terminal-playable MVP, 1–2 tests, and short “Learning Notes” pointing to items in python-oop-topics.txt.
- Quality gate every step: Build/install, Lint (optional), Tests (pytest -q), then manual terminal smoke.
- Engine/UI separation: Scenes use InputPort/OutputPort; terminal and Pygame are adapters only.

Phase 0 — Scaffold (done)
- Outcome: Shared engine (GameState, Scene ABC, IO protocols), terminal loop, Pygame stub, smoke tests.
- Demo: python -m orison shows intro → end.
- OOP: Levels 1–2 (classes, ABC), Level 5 (protocols), Level 6 (dataclass), Level 7 (typing basics).

Season 1 — The Broken Promise (core MVP)
1) Scene registry + routing
- Goal: Central registry maps scene_id → scene; transitions data-driven.
- OOP: Composition; explicit state transitions.
- Demo: Intro → AuditScene → Back to Intro → End via typed choices.

2) Data models: Mark and Contract (dataclasses)
- Goal: Mark(id, kind, is_witness), Contract(id, title, clauses, is_public) with __str__/__repr__.
- OOP: Level 6 dataclasses; Level 4 dunders.
- Demo: AuditScene prints a contract summary and a mark status.

3) Inventory and flags on GameState
- Goal: Add inventory: list[Mark], flags: dict[str, bool].
- OOP: Composition; state encapsulation.
- Demo: Pick up a Witness Mark in Intro; AuditScene detects it.

4) Dialogue choices (simple)
- Goal: Branching dialogues (question → 2–3 choices → effects on state).
- OOP: Small strategies/handlers.
- Demo: Choose “check ledger” vs “visit dock”; flags change and print.

5) Arbiter interaction placeholder
- Goal: Arbiter protocol and a mock Arbiter in terminal.
- OOP: ABCs/protocols; duck typing.
- Demo: Trade a memory (typed line) for a printed hint.

6) Secret clause reveal (conflict)
- Goal: Add second Contract conflicting with first; rule: if both active → canals “black”.
- OOP: Domain validation method.
- Demo: Toggle secret clause flips canal status banner.

7) Decision scene (branch A/B)
- Goal: Choose to restore public oath or legalize secret clause.
- OOP: Branching; state transition.
- Demo: Different “faction reaction” banners.

8) Faction reputation (minimal)
- Goal: reputation: dict[str, int]; helper adjust_rep(faction, delta).
- OOP: Encapsulation.
- Demo: Status screen prints reputations.

9) Ritual assembler (tiny puzzle)
- Goal: Combine 2 tokens; validate and produce a clause.
- OOP: Strategy pattern; validation.
- Demo: Success unlocks ending; failure loops with hint.

10) Save/load (basic)
- Goal: Save GameState to JSON (scene, flags, rep); load on start.
- OOP: Serialization; defaults.
- Demo: Quit mid-way; relaunch resumes same scene.

11) Error handling and input guards
- Goal: Guard invalid input; empty names; invalid menu.
- OOP: Defensive programming; validators.
- Demo: Bad input recovers without crash.

12) Season 1 wrap and test hardening
- Goal: Tests for key branches; polish.
- OOP: Unit testing seams; IO injection.
- Demo: All scenes reachable in <2 minutes of play.

Season 2 — Masks of Many Names
13) Mark authenticity checks
- Goal: Mark.authenticity + verify(mark).
- OOP: @property; service function vs method.
- Demo: Identify a fake token; print reason.

14) Orchard archive lookups
- Goal: Archive service; data in src/orison/data.
- OOP: DI of services; composition.
- Demo: Fetch and compare archive clause vs current.

15) Communal witnessing flow
- Goal: Validate without a token via multiple witnesses.
- OOP: Protocol-based witnesses; iterators/generators to collect input.
- Demo: “Community bound” success path.

16) Gala event scene (timed/ordered choices)
- Goal: Ordered prompts emulate urgency.
- OOP: Small state machine per scene.
- Demo: Different outcomes for order.

17) Counterfeit cleanup tool
- Goal: Scan inventory; flag fakes.
- OOP: Module service; tests.
- Demo: Menu tool prints counts.

Season 3 — The Family of Bridges
18) Waywright protocol vs bloodline
- Goal: WaywrightProtocol to “turn bridge”.
- OOP: typing.Protocol vs ABC; structural subtyping.
- Demo: Non-family candidate passes skill test.

19) Hierarchical rights model
- Goal: Baseline rights (family) + override (protocol).
- OOP: Composition; delegation.
- Demo: Bridge responds only when rules satisfied.

20) Bridge entity and actions
- Goal: Bridge.request_turn(); reasons printed.
- OOP: Encapsulation; clear method contracts.
- Demo: Refuses until recognition ceremony.

21) Recognition ceremony scene
- Goal: Ceremony flips flag; rep updates.
- OOP: Scene orchestration.
- Demo: Bridge turns; unlock banner.

Season 4 — The Rules of the Spirits
22) Arbiter classes and attributes
- Goal: mercy/strictness/preservation attributes.
- OOP: Polymorphism via config/fields.
- Demo: Show attribute used per domain.

23) Exposing attributes and selection
- Goal: Arbiters print which attribute they use and why.
- OOP: Strategy selection; transparency.
- Demo: Domain switch changes output.

24) Metacode compact (rules table)
- Goal: Map domain → attribute priority.
- OOP: Data-driven design.
- Demo: Toggle domain; see interpretation change.

Season 5 — Flood of Unfinished Promises
25) Promise fragments model
- Goal: PromiseFragment dataclass; merge tool.
- OOP: Data transforms.
- Demo: Reconstruct a vow from fragments.

26) Promise Loom (parallel)
- Goal: Queue multiple repairs; process “in parallel” (sequential simulation).
- OOP: Concurrency concepts; queues.
- Demo: Batch run shows per-promise results.

27) Registry triage scene
- Goal: Prioritize critical promises; rep impact.
- OOP: Scheduling heuristic.
- Demo: Print outcomes quickly.

Season 6 — The Unbinding and the Choice
28) City-scale options menu (forums)
- Goal: Track stances (freedom vs stability).
- OOP: State modeling of opinions.
- Demo: Visualize leaning.

29) The Last Contract (two clauses)
- Goal: Opt-out with review + public visibility with exit costs.
- OOP: Composite for clauses; validation chains.
- Demo: Choose final draft; different epilogues.

30) Epilogue and New Game+
- Goal: Summary screen; seed flags for future seasons.
- OOP: Persist high-level outcomes.
- Demo: New Game+ banner and options.

Ongoing quality and learning tracks
- Tests: 1–2 per step (happy path + one edge).
- Types: Gradually introduce Self, Protocols, Final, override.
- Performance: Revisit in Season 5 (queues); consider __slots__.
- Docs: Append “Learning Notes” for each shipped step.

Terminal demos (always)
- Run: python -m orison
- Verify: Reach new feature within ~2 minutes with clear prompts.
- Rollback: If a step feels big, split and ship half.

Next step
- Implement Step 1 (Scene registry + routing) and Step 2 (Mark/Contract dataclasses) with tiny demos and tests; then pause for review.
